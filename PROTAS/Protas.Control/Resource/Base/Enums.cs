namespace Protas.Control.Resource.Base
{
    /// <summary>
    /// Режим сущности. Ресурс в данной сущности уже готовый или его необходимо инициализиваровать в контексте или сам
    /// </summary>
    public enum EntityMode
    {
        /// <summary>
        /// Обычный, возможно с дефолтным конструктором или вообще без конструктора. Создается сам без участия контекста IResourceContext.GetResource()
        /// </summary>
        None = 0,
        /// <summary>
        /// Уже готовый ресурс
        /// </summary>
        Ready = 1,
        /// <summary>
        /// Необычный, инициализация ресурса происходит в самом конетексте - который создается с помощью контекста IResourceContext.GetResource()
        /// </summary>
        Unusual = 2
    }

    /// <summary>
    /// Тип непсредстевнного ресурса (Константа, Всегда Уникальный, Разный - в зависимости от написания)
    /// </summary>
    public enum ResultType
    {
        /// <summary>
        /// Постоянный. 
        /// Не может быть эвентом.
        /// Одноразовый ресурс. Если с входными конструкторами результат ресурса будет всегда один и тот же.
        /// Например Matches('111','\d+'), входные конструкторы статичны значит и значение свойства GetResult() всегда будет одно и тоже.
        /// </summary>
        Constant = 0,

        /// <summary>
        /// Вечно новое значение, основываясь на настройке таймера интервала на обновление ресурса!!!! 
        /// (в исключительных случая может быть не уникальным, но подразумевается как вечно уникальный как CPU RAM Random Datetaime.Now.ToString("fffff"))
        /// на конечном выходе всегда будет уникальным
        /// Может быть эвентом.
        /// Невозможно узнать результат точно пока не вызвать возвращенное свойтво из возвращенного метода XPack при выполнении инициализации Initialize.
        /// ОСНОВНОЕ НО!!!! Необходимо правильно настроить унаследованный класс ResourceUniqueFrame, т.к.
        /// нельзя чтобы данный тип использовали тяжелые операции как например запрос состояния CPU, так как если
        /// ресурс унаследован от ResourceUniqueFrame и будет задан как эвент то в периодичность вызова состояния CPU 
        /// будет состалвять 50 мсек, очень сильно на сам процессор данный ресурс повляет, если не перезадать свойство UpdateResource.Interval
        /// Пример: если ресурсом является Random или Now, мы можем предполагать что значения при вызове всегда будут разные
        /// Он так же относится к типу неопределенных, но данный ресурс не может являться эвентом, т.к. это может повлиять на производительность системы
        /// По дефолту если данный компонент будет эвентом, то создается таймер который каждый определенный период времени 
        /// вызывает эвент ComponentPossibleChanged каждый 100 мсек
        /// </summary>
        InfinityUnique = 1,

        /// <summary>
        /// Индивидуальный. Может быть с разной спецификой инициирования эвентов, может быть отличным от InfinityUnique, не используя таймера по обновлению ресурса.
        /// Предназначение данного ресурса свойственно в связке с эвентами других объектов данного ресурса, но не как таймер (если юзается таймер то это ресурс Infinity)!
        /// Может быть эвентом.
        /// Напрмимер это зачастую может быть ресурс который задан как парсер значений из какойго нибудь файла,
        /// но значение в файле может поменять кто угодно или файл вообще удален, пока не вызвать XPack.Value который при инициализации был создан как делегат и узнать значение.
        /// Но это не относится к таким компонентам как запрос например запрос процента CPU
        /// потому что если IsUncertain задан как true (неопределен), то неизвестно с какой частотой будет вызываться XPack.Value
        /// (по дефолту расчитывается среднее время обработки данного компонента + одна секунда)
        /// и возможно что это повлечет к сильной загрузке компютера и отбора большого количество системных ресурсов
        /// </summary>
        Specific = 2
    }

}
