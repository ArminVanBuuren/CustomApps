<root>
  <assemblies>
    <assembly>System.dll</assembly>
  </assemblies>
  <namespaces>
    using System;
    using System.Text.RegularExpressions;
    using System.Xml.XPath;
    using System.Xml.Xsl;
    using System.IO;
    using System.Reflection;
    using System.Text;
  </namespaces>
  <functions>
    <getTimeInRange>
      <summary>
        <syntax>getTimeInRange(timeZone, from, to)</syntax>
        <definition>
          timeZone define time zone shift in minutes
          Returns empty string if the current time is in the range (from, to).
          Otherwise returns random time within first spreadMinutes minutes of the range (from, to).
          Default value of spread is 120 minutes. Custom value of spread can be passed throw third parameter.
          Format of bounds must be 'hh:mm'.
        </definition>
      </summary>
      <code>
        <![CDATA[
    public class getTimeInRangeFunction : IXsltContextFunction
    {
        public int Minargs
        {
            get { return 3; }
        }

        public int Maxargs
        {
            get { return 4; }
        }

        public XPathResultType ReturnType
        {
            get { return XPathResultType.String; }
        }

        public XPathResultType[] ArgTypes
        {
            get { return new XPathResultType[] { XPathResultType.String, XPathResultType.String, XPathResultType.String }; }
        }

        public object Invoke(XsltContext xsltContext,
                             object[] args, XPathNavigator docContext)
        {
            try
            {
                string sTimeZone = args[0].ToString();
                Int32 timeZone;
                if (Int32.TryParse(sTimeZone, out timeZone))
                {
                    timeZone = Convert.ToInt32(sTimeZone);
                }
                else
                {
                    timeZone = 0;
                }
                string sFrom = args[1].ToString();
                string sTo = args[2].ToString();
                int spreadMinutes = (args.Length > 3) ? Convert.ToInt32(args[3].ToString()) : 120;
                //default value of spread is 120 minutes

                DateTime now = DateTime.Now;
                DateTime dFrom = new DateTime(now.Year, now.Month, now.Day, 0, 0, 0);
                dFrom = dFrom + stringToTimeSpan(sFrom);
                dFrom = dFrom + TimeSpan.FromMinutes(timeZone);
                DateTime dTo = new DateTime(now.Year, now.Month, now.Day, 0, 0, 0);
                dTo = dTo + stringToTimeSpan(sTo);
                dTo = dTo + TimeSpan.FromMinutes(timeZone);

                if (now >= dFrom && now <= dTo) return "";

                Random randomShift = new Random();
                if (now < dFrom)
                    return timespanToString(dFrom - now + TimeSpan.FromMinutes(randomShift.Next(spreadMinutes)));
                if (now > dFrom)
                    return
                        timespanToString(dFrom.AddDays(1) - now + TimeSpan.FromMinutes(randomShift.Next(spreadMinutes)));
                return "";
            }
            catch (Exception e)
            {
                return e.Message;
            }
        }

        static string timespanToString(TimeSpan timespan)
        {
            return String.Format("0000{0:00}{1:00}{2:00}{3:00}000R", timespan.Days, timespan.Hours, timespan.Minutes, timespan.Seconds);
        }

        static TimeSpan stringToTimeSpan(string span)
        {
            Regex rx = new Regex(@"((?<days>(\d+))\.)?(?<hours>(\d{1,2})):(?<mins>(\d{1,2}))");
            Match match = rx.Match(span);
            GroupCollection groups = match.Groups;
            Int32 days = 0;
            try
            {
                days = Convert.ToInt32(groups["days"].Value);
            }
            catch
            {
                days = 0;
            }
            TimeSpan timeSpan = new TimeSpan(days, Convert.ToInt32(groups["hours"].Value), Convert.ToInt32(groups["mins"].Value), 0);
            return timeSpan;
        }
    }
]]>
      </code>
    </getTimeInRange>
    <ToLower>
      <summary>
        <syntax>ToLower(string)</syntax>
        <definition>
          Created by Vladimir Khovanskiy. ISSUE - 1261689
        </definition>
      </summary>
      <code>
        <![CDATA[
    public class ToLowerFunction : IXsltContextFunction
    {
        public int Minargs
        {
            get { return 1; }
        }

        public int Maxargs
        {
            get { return 1; }
        }

        public XPathResultType ReturnType
        {
            get { return XPathResultType.String; }
        }

        public XPathResultType[] ArgTypes
        {
            get { return new XPathResultType[] { XPathResultType.String }; }
        }

        public object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
        {
            if (args == null)
                throw new ArgumentNullException("args");
            if (args.Length != 1)
                throw new ArgumentException("Function ToLower() takes only one parameter");

            return ((string)args[0]).ToLower();
        }
    }
]]>
      </code>
    </ToLower>
    <Format>
      <summary>
        <syntax>Format(string, string)</syntax>
        <definition>
          Created by Vladimir Khovanskiy. ISSUE - 1261689; Task - 1267189
          params - splitting by sign '|'
        </definition>
      </summary>
      <code>
        <![CDATA[
    public class FormatFunction : IXsltContextFunction
    {
        public int Minargs
        {
            get { return 2; }
        }

        public int Maxargs
        {
            get { return 2; }
        }

        public XPathResultType ReturnType
        {
            get { return XPathResultType.String; }
        }

        public XPathResultType[] ArgTypes
        {
            get { return new[] { XPathResultType.String, XPathResultType.String }; }
        }

        public object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
        {
            if (args == null)
                throw new ArgumentNullException("args");
            if (args.Length != 2)
                throw new ArgumentException("Function Format() takes only two parameters");

            return string.Format(((string)args[0]).Replace("[", "{").Replace("]", "}"), ((string)args[1]).Split('|'));
        }
    }
]]>
      </code>
    </Format>
    <XmlReplacer>
      <summary>
        <syntax>XmlReplacer(string)</syntax>
        <definition>
          Created by Vladimir Khovanskiy.
          Replace xml entity names to related char.
        </definition>
      </summary>
      <code>
        <![CDATA[
    public class XmlReplacerFunction : IXsltContextFunction
    {
        public int Minargs
        {
            get { return 1; }
        }

        public int Maxargs
        {
            get { return 1; }
        }

        public XPathResultType ReturnType
        {
            get { return XPathResultType.String; }
        }

        public XPathResultType[] ArgTypes
        {
            get { return new[] { XPathResultType.String, XPathResultType.String }; }
        }

        public object Invoke(XsltContext xsltContext, object[] args, XPathNavigator docContext)
        {
            if (args == null)
                throw new ArgumentNullException("args");
            if (args.Length != 1)
                throw new ArgumentException("Function XmlReplacer() takes only one parameter");

            return ((string)args[0]).Replace("&amp;", "&")
                                    .Replace("&apos;", "'")
                                    .Replace("&quot;", "\"")
                                    .Replace("&lt;", "<")
                                    .Replace("&gt;", ">");
        }
    }
]]>
      </code>
    </XmlReplacer>
  </functions>
</root>